{"ast":null,"code":"import { Response } from \"miragejs\";\nimport { formatDate, requiresAuth } from \"../utils/authUtils\";\nimport { v4 as uuid } from \"uuid\";\n/**\n * All the routes related to Order are present here.\n * These are private routes.\n * Client needs to add \"authorization\" header with JWT token in it to access it.\n * */\n\n/**\n * This handler handles getting items to user's orders.\n * send GET Request at /api/user/order\n * */\n\nexport const getOrdersHandler = function (schema, request) {\n  const userId = requiresAuth.call(this, request);\n\n  if (!userId) {\n    new Response(404, {}, {\n      errors: [\"The email you entered is not Registered. Not Found error\"]\n    });\n  }\n\n  const userOrders = schema.users.findBy({\n    _id: userId\n  }).orders;\n  return new Response(200, {}, {\n    order: userOrders\n  });\n};\n/**\n * This handler handles adding items to user's orders.\n * send POST Request at /api/user/order\n * body contains {order}\n * */\n\nexport const addOrdersHandler = function (schema, request) {\n  const userId = requiresAuth.call(this, request);\n\n  try {\n    if (!userId) {\n      new Response(404, {}, {\n        errors: [\"The email you entered is not Registered. Not Found error\"]\n      });\n    }\n\n    const userOrders = schema.users.findBy({\n      _id: userId\n    }).orders;\n    const {\n      order\n    } = JSON.parse(request.requestBody);\n    userOrders.push({ ...order,\n      createdAt: formatDate(),\n      updatedAt: formatDate(),\n      _id: uuid()\n    });\n    this.db.users.update({\n      _id: userId\n    }, {\n      order: userOrders\n    });\n    this.db.users.update({\n      _id: userId\n    }, {\n      cart: []\n    });\n    return new Response(201, {}, {\n      order: userOrders\n    });\n  } catch (error) {\n    return new Response(500, {}, {\n      error\n    });\n  }\n};","map":{"version":3,"sources":["/Users/anupjaiswal/Desktop/e_commerce/src/backend/controllers/OrderController.js"],"names":["Response","formatDate","requiresAuth","v4","uuid","getOrdersHandler","schema","request","userId","call","errors","userOrders","users","findBy","_id","orders","order","addOrdersHandler","JSON","parse","requestBody","push","createdAt","updatedAt","db","update","cart","error"],"mappings":"AAAA,SAASA,QAAT,QAAyB,UAAzB;AACA,SAASC,UAAT,EAAqBC,YAArB,QAAyC,oBAAzC;AACA,SAASC,EAAE,IAAIC,IAAf,QAA2B,MAA3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AACA,OAAO,MAAMC,gBAAgB,GAAG,UAAUC,MAAV,EAAkBC,OAAlB,EAA2B;AACzD,QAAMC,MAAM,GAAGN,YAAY,CAACO,IAAb,CAAkB,IAAlB,EAAwBF,OAAxB,CAAf;;AACA,MAAI,CAACC,MAAL,EAAa;AACX,QAAIR,QAAJ,CACE,GADF,EAEE,EAFF,EAGE;AACEU,MAAAA,MAAM,EAAE,CAAC,0DAAD;AADV,KAHF;AAOD;;AACD,QAAMC,UAAU,GAAGL,MAAM,CAACM,KAAP,CAAaC,MAAb,CAAoB;AAAEC,IAAAA,GAAG,EAAEN;AAAP,GAApB,EAAqCO,MAAxD;AACA,SAAO,IAAIf,QAAJ,CAAa,GAAb,EAAkB,EAAlB,EAAsB;AAAEgB,IAAAA,KAAK,EAAEL;AAAT,GAAtB,CAAP;AACD,CAbM;AAeP;AACA;AACA;AACA;AACA;;AAEA,OAAO,MAAMM,gBAAgB,GAAG,UAAUX,MAAV,EAAkBC,OAAlB,EAA2B;AACzD,QAAMC,MAAM,GAAGN,YAAY,CAACO,IAAb,CAAkB,IAAlB,EAAwBF,OAAxB,CAAf;;AACA,MAAI;AACF,QAAI,CAACC,MAAL,EAAa;AACX,UAAIR,QAAJ,CACE,GADF,EAEE,EAFF,EAGE;AACEU,QAAAA,MAAM,EAAE,CAAC,0DAAD;AADV,OAHF;AAOD;;AACD,UAAMC,UAAU,GAAGL,MAAM,CAACM,KAAP,CAAaC,MAAb,CAAoB;AAAEC,MAAAA,GAAG,EAAEN;AAAP,KAApB,EAAqCO,MAAxD;AACA,UAAM;AAAEC,MAAAA;AAAF,QAAYE,IAAI,CAACC,KAAL,CAAWZ,OAAO,CAACa,WAAnB,CAAlB;AACAT,IAAAA,UAAU,CAACU,IAAX,CAAgB,EACd,GAAGL,KADW;AAEdM,MAAAA,SAAS,EAAErB,UAAU,EAFP;AAGdsB,MAAAA,SAAS,EAAEtB,UAAU,EAHP;AAIda,MAAAA,GAAG,EAAEV,IAAI;AAJK,KAAhB;AAMA,SAAKoB,EAAL,CAAQZ,KAAR,CAAca,MAAd,CAAqB;AAAEX,MAAAA,GAAG,EAAEN;AAAP,KAArB,EAAsC;AAAEQ,MAAAA,KAAK,EAAEL;AAAT,KAAtC;AACA,SAAKa,EAAL,CAAQZ,KAAR,CAAca,MAAd,CAAqB;AAAEX,MAAAA,GAAG,EAAEN;AAAP,KAArB,EAAsC;AAAEkB,MAAAA,IAAI,EAAE;AAAR,KAAtC;AACA,WAAO,IAAI1B,QAAJ,CAAa,GAAb,EAAkB,EAAlB,EAAsB;AAAEgB,MAAAA,KAAK,EAAEL;AAAT,KAAtB,CAAP;AACD,GArBD,CAqBE,OAAOgB,KAAP,EAAc;AACd,WAAO,IAAI3B,QAAJ,CACL,GADK,EAEL,EAFK,EAGL;AACE2B,MAAAA;AADF,KAHK,CAAP;AAOD;AACF,CAhCM","sourcesContent":["import { Response } from \"miragejs\";\nimport { formatDate, requiresAuth } from \"../utils/authUtils\";\nimport { v4 as uuid } from \"uuid\";\n/**\n * All the routes related to Order are present here.\n * These are private routes.\n * Client needs to add \"authorization\" header with JWT token in it to access it.\n * */\n\n/**\n * This handler handles getting items to user's orders.\n * send GET Request at /api/user/order\n * */\nexport const getOrdersHandler = function (schema, request) {\n  const userId = requiresAuth.call(this, request);\n  if (!userId) {\n    new Response(\n      404,\n      {},\n      {\n        errors: [\"The email you entered is not Registered. Not Found error\"],\n      }\n    );\n  }\n  const userOrders = schema.users.findBy({ _id: userId }).orders;\n  return new Response(200, {}, { order: userOrders });\n};\n\n/**\n * This handler handles adding items to user's orders.\n * send POST Request at /api/user/order\n * body contains {order}\n * */\n\nexport const addOrdersHandler = function (schema, request) {\n  const userId = requiresAuth.call(this, request);\n  try {\n    if (!userId) {\n      new Response(\n        404,\n        {},\n        {\n          errors: [\"The email you entered is not Registered. Not Found error\"],\n        }\n      );\n    }\n    const userOrders = schema.users.findBy({ _id: userId }).orders;\n    const { order } = JSON.parse(request.requestBody);\n    userOrders.push({\n      ...order,\n      createdAt: formatDate(),\n      updatedAt: formatDate(),\n      _id: uuid(),\n    });\n    this.db.users.update({ _id: userId }, { order: userOrders });\n    this.db.users.update({ _id: userId }, { cart: [] });\n    return new Response(201, {}, { order: userOrders });\n  } catch (error) {\n    return new Response(\n      500,\n      {},\n      {\n        error,\n      }\n    );\n  }\n};\n"]},"metadata":{},"sourceType":"module"}